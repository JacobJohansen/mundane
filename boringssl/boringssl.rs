// Copyright 2018 Google LLC
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

// Some symbols are only used with certain features enabled, so we need to
// suppress the unused warning when those features aren't enabled.
#![allow(unused)]
// Only necessary for test_symbol_conflict.sh, which exposes these symbols
// through Mundane's public interface.
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

#[link(name = "crypto_0_2_2")]
extern "C" {}

/* automatically generated by rust-bindgen */

pub const ED25519_PRIVATE_KEY_LEN: u32 = 64;
pub const ED25519_PUBLIC_KEY_LEN: u32 = 32;
pub const ED25519_SIGNATURE_LEN: u32 = 64;
pub const NID_X9_62_prime256v1: u32 = 415;
pub const NID_secp384r1: u32 = 715;
pub const NID_secp521r1: u32 = 716;
pub const SHA_DIGEST_LENGTH: u32 = 20;
pub const SHA256_DIGEST_LENGTH: u32 = 32;
pub const SHA384_DIGEST_LENGTH: u32 = 48;
pub const SHA512_DIGEST_LENGTH: u32 = 64;
pub type CBB = cbb_st;
pub type CBS = cbs_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dh_st {
    _unused: [u8; 0],
}
pub type DH = dh_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_st {
    _unused: [u8; 0],
}
pub type DSA = dsa_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_group_st {
    _unused: [u8; 0],
}
pub type EC_GROUP = ec_group_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_key_st {
    _unused: [u8; 0],
}
pub type EC_KEY = ec_key_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct engine_st {
    _unused: [u8; 0],
}
pub type ENGINE = engine_st;
pub type EVP_MD_CTX = env_md_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct env_md_st {
    _unused: [u8; 0],
}
pub type EVP_MD = env_md_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_asn1_method_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_ASN1_METHOD = evp_pkey_asn1_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_CTX = evp_pkey_ctx_st;
pub type EVP_PKEY = evp_pkey_st;
pub type HMAC_CTX = hmac_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_st {
    _unused: [u8; 0],
}
pub type RSA = rsa_st;
pub type SHA256_CTX = sha256_state_st;
pub type SHA512_CTX = sha512_state_st;
pub type SHA_CTX = sha_state_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbs_st {
    pub data: *const u8,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_cbs_st() {
    assert_eq!(
        ::std::mem::size_of::<cbs_st>(),
        16usize,
        concat!("Size of: ", stringify!(cbs_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cbs_st>(),
        8usize,
        concat!("Alignment of ", stringify!(cbs_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbs_st>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbs_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbs_st>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbs_st),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_CBS_init"]
    pub fn CBS_init(cbs: *mut CBS, data: *const u8, len: usize);
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_CBS_len"]
    pub fn CBS_len(cbs: *const CBS) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbb_buffer_st {
    pub buf: *mut u8,
    pub len: usize,
    pub cap: usize,
    pub can_resize: ::std::os::raw::c_char,
    pub error: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cbb_buffer_st() {
    assert_eq!(
        ::std::mem::size_of::<cbb_buffer_st>(),
        32usize,
        concat!("Size of: ", stringify!(cbb_buffer_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cbb_buffer_st>(),
        8usize,
        concat!("Alignment of ", stringify!(cbb_buffer_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_buffer_st),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_buffer_st),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).cap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_buffer_st),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).can_resize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_buffer_st),
            "::",
            stringify!(can_resize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_buffer_st>())).error as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_buffer_st),
            "::",
            stringify!(error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbb_st {
    pub base: *mut cbb_buffer_st,
    pub child: *mut CBB,
    pub offset: usize,
    pub pending_len_len: u8,
    pub pending_is_asn1: ::std::os::raw::c_char,
    pub is_top_level: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cbb_st() {
    assert_eq!(
        ::std::mem::size_of::<cbb_st>(),
        32usize,
        concat!("Size of: ", stringify!(cbb_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cbb_st>(),
        8usize,
        concat!("Alignment of ", stringify!(cbb_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_st>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_st),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_st>())).child as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_st),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_st>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_st>())).pending_len_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_st),
            "::",
            stringify!(pending_len_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_st>())).pending_is_asn1 as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_st),
            "::",
            stringify!(pending_is_asn1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cbb_st>())).is_top_level as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_st),
            "::",
            stringify!(is_top_level)
        )
    );
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_CBB_init"]
    pub fn CBB_init(cbb: *mut CBB, initial_capacity: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_CBB_cleanup"]
    pub fn CBB_cleanup(cbb: *mut CBB);
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_CBB_data"]
    pub fn CBB_data(cbb: *const CBB) -> *const u8;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_CBB_len"]
    pub fn CBB_len(cbb: *const CBB) -> usize;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_ED25519_keypair"]
    pub fn ED25519_keypair(out_public_key: *mut u8, out_private_key: *mut u8);
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_ED25519_sign"]
    pub fn ED25519_sign(
        out_sig: *mut u8, message: *const u8, message_len: usize, private_key: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_ED25519_verify"]
    pub fn ED25519_verify(
        message: *const u8, message_len: usize, signature: *const u8, public_key: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_ED25519_keypair_from_seed"]
    pub fn ED25519_keypair_from_seed(
        out_public_key: *mut u8, out_private_key: *mut u8, seed: *const u8,
    );
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EC_GROUP_new_by_curve_name"]
    pub fn EC_GROUP_new_by_curve_name(nid: ::std::os::raw::c_int) -> *mut EC_GROUP;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EC_GROUP_get_curve_name"]
    pub fn EC_GROUP_get_curve_name(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EC_curve_nid2nist"]
    pub fn EC_curve_nid2nist(nid: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EC_KEY_new"]
    pub fn EC_KEY_new() -> *mut EC_KEY;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EC_KEY_free"]
    pub fn EC_KEY_free(key: *mut EC_KEY);
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EC_KEY_up_ref"]
    pub fn EC_KEY_up_ref(key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EC_KEY_get0_group"]
    pub fn EC_KEY_get0_group(key: *const EC_KEY) -> *const EC_GROUP;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EC_KEY_set_group"]
    pub fn EC_KEY_set_group(key: *mut EC_KEY, group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EC_KEY_generate_key"]
    pub fn EC_KEY_generate_key(key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EC_KEY_parse_private_key"]
    pub fn EC_KEY_parse_private_key(cbs: *mut CBS, group: *const EC_GROUP) -> *mut EC_KEY;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EC_KEY_marshal_private_key"]
    pub fn EC_KEY_marshal_private_key(
        cbb: *mut CBB, key: *const EC_KEY, enc_flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_ECDSA_sign"]
    pub fn ECDSA_sign(
        type_: ::std::os::raw::c_int, digest: *const u8, digest_len: usize, sig: *mut u8,
        sig_len: *mut ::std::os::raw::c_uint, key: *const EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_ECDSA_verify"]
    pub fn ECDSA_verify(
        type_: ::std::os::raw::c_int, digest: *const u8, digest_len: usize, sig: *const u8,
        sig_len: usize, key: *const EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_ECDSA_size"]
    pub fn ECDSA_size(key: *const EC_KEY) -> usize;
}
pub type ERR_print_errors_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        str: *const ::std::os::raw::c_char,
        len: usize,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_ERR_print_errors_cb"]
    pub fn ERR_print_errors_cb(
        callback: ERR_print_errors_callback_t, ctx: *mut ::std::os::raw::c_void,
    );
}
pub type CRYPTO_refcount_t = u32;
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EVP_sha1"]
    pub fn EVP_sha1() -> *const EVP_MD;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EVP_sha256"]
    pub fn EVP_sha256() -> *const EVP_MD;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EVP_sha384"]
    pub fn EVP_sha384() -> *const EVP_MD;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EVP_sha512"]
    pub fn EVP_sha512() -> *const EVP_MD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_md_pctx_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct env_md_ctx_st {
    pub digest: *const EVP_MD,
    pub md_data: *mut ::std::os::raw::c_void,
    pub pctx: *mut EVP_PKEY_CTX,
    pub pctx_ops: *const evp_md_pctx_ops,
}
#[test]
fn bindgen_test_layout_env_md_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<env_md_ctx_st>(),
        32usize,
        concat!("Size of: ", stringify!(env_md_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<env_md_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(env_md_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).digest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(digest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).md_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(md_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).pctx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(pctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<env_md_ctx_st>())).pctx_ops as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(pctx_ops)
        )
    );
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EVP_PKEY_new"]
    pub fn EVP_PKEY_new() -> *mut EVP_PKEY;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EVP_PKEY_free"]
    pub fn EVP_PKEY_free(pkey: *mut EVP_PKEY);
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EVP_PKEY_up_ref"]
    pub fn EVP_PKEY_up_ref(pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EVP_PKEY_assign_EC_KEY"]
    pub fn EVP_PKEY_assign_EC_KEY(pkey: *mut EVP_PKEY, key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EVP_PKEY_get1_EC_KEY"]
    pub fn EVP_PKEY_get1_EC_KEY(pkey: *const EVP_PKEY) -> *mut EC_KEY;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EVP_parse_public_key"]
    pub fn EVP_parse_public_key(cbs: *mut CBS) -> *mut EVP_PKEY;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EVP_marshal_public_key"]
    pub fn EVP_marshal_public_key(cbb: *mut CBB, key: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_PKCS5_PBKDF2_HMAC"]
    pub fn PKCS5_PBKDF2_HMAC(
        password: *const ::std::os::raw::c_char, password_len: usize, salt: *const u8,
        salt_len: usize, iterations: ::std::os::raw::c_uint, digest: *const EVP_MD, key_len: usize,
        out_key: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_EVP_PBE_scrypt"]
    pub fn EVP_PBE_scrypt(
        password: *const ::std::os::raw::c_char, password_len: usize, salt: *const u8,
        salt_len: usize, N: u64, r: u64, p: u64, max_mem: usize, out_key: *mut u8, key_len: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct evp_pkey_st {
    pub references: CRYPTO_refcount_t,
    pub type_: ::std::os::raw::c_int,
    pub pkey: evp_pkey_st__bindgen_ty_1,
    pub ameth: *const EVP_PKEY_ASN1_METHOD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union evp_pkey_st__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_void,
    pub rsa: *mut RSA,
    pub dsa: *mut DSA,
    pub dh: *mut DH,
    pub ec: *mut EC_KEY,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_evp_pkey_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<evp_pkey_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(evp_pkey_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_pkey_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_pkey_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).rsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st__bindgen_ty_1),
            "::",
            stringify!(rsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).dsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st__bindgen_ty_1),
            "::",
            stringify!(dsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).dh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st__bindgen_ty_1),
            "::",
            stringify!(dh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st__bindgen_ty_1>())).ec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st__bindgen_ty_1),
            "::",
            stringify!(ec)
        )
    );
}
#[test]
fn bindgen_test_layout_evp_pkey_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_pkey_st>(),
        24usize,
        concat!("Size of: ", stringify!(evp_pkey_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_pkey_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_pkey_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).references as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).pkey as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_pkey_st>())).ameth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_pkey_st),
            "::",
            stringify!(ameth)
        )
    );
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_HMAC_CTX_init"]
    pub fn HMAC_CTX_init(ctx: *mut HMAC_CTX);
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_HMAC_CTX_cleanup"]
    pub fn HMAC_CTX_cleanup(ctx: *mut HMAC_CTX);
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_HMAC_Init_ex"]
    pub fn HMAC_Init_ex(
        ctx: *mut HMAC_CTX, key: *const ::std::os::raw::c_void, key_len: usize, md: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_HMAC_Update"]
    pub fn HMAC_Update(
        ctx: *mut HMAC_CTX, data: *const u8, data_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_HMAC_Final"]
    pub fn HMAC_Final(
        ctx: *mut HMAC_CTX, out: *mut u8, out_len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_HMAC_size"]
    pub fn HMAC_size(ctx: *const HMAC_CTX) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmac_ctx_st {
    pub md: *const EVP_MD,
    pub md_ctx: EVP_MD_CTX,
    pub i_ctx: EVP_MD_CTX,
    pub o_ctx: EVP_MD_CTX,
}
#[test]
fn bindgen_test_layout_hmac_ctx_st() {
    assert_eq!(
        ::std::mem::size_of::<hmac_ctx_st>(),
        104usize,
        concat!("Size of: ", stringify!(hmac_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hmac_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(hmac_ctx_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).md as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(md)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).md_ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(md_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).i_ctx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(i_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hmac_ctx_st>())).o_ctx as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(o_ctx)
        )
    );
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_CRYPTO_memcmp"]
    pub fn CRYPTO_memcmp(
        a: *const ::std::os::raw::c_void, b: *const ::std::os::raw::c_void, len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_RAND_bytes"]
    pub fn RAND_bytes(buf: *mut u8, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_SHA1_Init"]
    pub fn SHA1_Init(sha: *mut SHA_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_SHA1_Update"]
    pub fn SHA1_Update(
        sha: *mut SHA_CTX, data: *const ::std::os::raw::c_void, len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_SHA1_Final"]
    pub fn SHA1_Final(md: *mut u8, sha: *mut SHA_CTX) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sha_state_st {
    pub __bindgen_anon_1: sha_state_st__bindgen_ty_1,
    pub Nl: u32,
    pub Nh: u32,
    pub data: [u8; 64usize],
    pub num: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sha_state_st__bindgen_ty_1 {
    pub h: [u32; 5usize],
    pub __bindgen_anon_1: sha_state_st__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u32; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha_state_st__bindgen_ty_1__bindgen_ty_1 {
    pub h0: u32,
    pub h1: u32,
    pub h2: u32,
    pub h3: u32,
    pub h4: u32,
}
#[test]
fn bindgen_test_layout_sha_state_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sha_state_st__bindgen_ty_1__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sha_state_st__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h0 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h1 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h2 as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h3 as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1__bindgen_ty_1>())).h4 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h4)
        )
    );
}
#[test]
fn bindgen_test_layout_sha_state_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sha_state_st__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(sha_state_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sha_state_st__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sha_state_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha_state_st__bindgen_ty_1>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st__bindgen_ty_1),
            "::",
            stringify!(h)
        )
    );
}
#[test]
fn bindgen_test_layout_sha_state_st() {
    assert_eq!(
        ::std::mem::size_of::<sha_state_st>(),
        96usize,
        concat!("Size of: ", stringify!(sha_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<sha_state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(sha_state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha_state_st>())).Nl as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha_state_st>())).Nh as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha_state_st>())).data as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha_state_st>())).num as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st),
            "::",
            stringify!(num)
        )
    );
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_SHA256_Init"]
    pub fn SHA256_Init(sha: *mut SHA256_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_SHA256_Update"]
    pub fn SHA256_Update(
        sha: *mut SHA256_CTX, data: *const ::std::os::raw::c_void, len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_SHA256_Final"]
    pub fn SHA256_Final(md: *mut u8, sha: *mut SHA256_CTX) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sha256_state_st {
    pub h: [u32; 8usize],
    pub Nl: u32,
    pub Nh: u32,
    pub data: [u8; 64usize],
    pub num: ::std::os::raw::c_uint,
    pub md_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_sha256_state_st() {
    assert_eq!(
        ::std::mem::size_of::<sha256_state_st>(),
        112usize,
        concat!("Size of: ", stringify!(sha256_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<sha256_state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(sha256_state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).Nl as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).Nh as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_state_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).num as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_state_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha256_state_st>())).md_len as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_state_st),
            "::",
            stringify!(md_len)
        )
    );
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_SHA384_Init"]
    pub fn SHA384_Init(sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_SHA384_Update"]
    pub fn SHA384_Update(
        sha: *mut SHA512_CTX, data: *const ::std::os::raw::c_void, len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_SHA384_Final"]
    pub fn SHA384_Final(md: *mut u8, sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_SHA512_Init"]
    pub fn SHA512_Init(sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_SHA512_Update"]
    pub fn SHA512_Update(
        sha: *mut SHA512_CTX, data: *const ::std::os::raw::c_void, len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__RUST_MUNDANE_0_2_2_SHA512_Final"]
    pub fn SHA512_Final(md: *mut u8, sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sha512_state_st {
    pub h: [u64; 8usize],
    pub Nl: u64,
    pub Nh: u64,
    pub u: sha512_state_st__bindgen_ty_1,
    pub num: ::std::os::raw::c_uint,
    pub md_len: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sha512_state_st__bindgen_ty_1 {
    pub d: [u64; 16usize],
    pub p: [u8; 128usize],
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_sha512_state_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sha512_state_st__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(sha512_state_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sha512_state_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sha512_state_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha512_state_st__bindgen_ty_1>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_state_st__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha512_state_st__bindgen_ty_1>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_state_st__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
}
#[test]
fn bindgen_test_layout_sha512_state_st() {
    assert_eq!(
        ::std::mem::size_of::<sha512_state_st>(),
        216usize,
        concat!("Size of: ", stringify!(sha512_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<sha512_state_st>(),
        8usize,
        concat!("Alignment of ", stringify!(sha512_state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).Nl as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).Nh as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).u as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_state_st),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).num as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_state_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sha512_state_st>())).md_len as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_state_st),
            "::",
            stringify!(md_len)
        )
    );
}
